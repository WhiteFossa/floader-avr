,,,       
,,,       
,,,       .include "m16def.inc"
,,,       
,,,       ;***** Created: 2010-02-25 11:46 ******* Source: ATmega16.xml ************
,,,       ;*************************************************************************
,,,       ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
,,,       ;* 
,,,       ;* Number            : AVR000
,,,       ;* File Name         : "m16def.inc"
,,,       ;* Title             : Register/Bit Definitions for the ATmega16
,,,       ;* Date              : 2010-02-25
,,,       ;* Version           : 2.35
,,,       ;* Support E-mail    : avr@atmel.com
,,,       ;* Target MCU        : ATmega16
,,,       ;* 
,,,       ;* DESCRIPTION
,,,       ;* When including this file in the assembly program file, all I/O register 
,,,       ;* names and I/O register bit names appearing in the data book can be used.
,,,       ;* In addition, the six registers forming the three data pointers X, Y and 
,,,       ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
,,,       ;* SRAM is also defined 
,,,       ;* 
,,,       ;* The Register names are represented by their hexadecimal address.
,,,       ;* 
,,,       ;* The Register Bit names are represented by their bit number (0-7).
,,,       ;* 
,,,       ;* Please observe the difference in using the bit names with instructions
,,,       ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
,,,       ;* (skip if bit in register set/cleared). The following example illustrates
,,,       ;* this:
,,,       ;* 
,,,       ;* in    r16,PORTB             ;read PORTB latch
,,,       ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
,,,       ;* out   PORTB,r16             ;output to PORTB
,,,       ;* 
,,,       ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
,,,       ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
,,,       ;* rjmp  TOV0_is_set           ;jump if set
,,,       ;* ...                         ;otherwise do something else
,,,       ;*************************************************************************
,,,       
,,,       #ifndef _M16DEF_INC_
,,,       #define _M16DEF_INC_
,,,       
,,,       
,,,       #pragma partinc 0
,,,       
,,,       ; ***** SPECIFY DEVICE ***************************************************
,,,       .device ATmega16
,,,       #pragma AVRPART ADMIN PART_NAME ATmega16
,,,       .equ   SIGNATURE_000   = 0x1e
,,,       .equ   SIGNATURE_001   = 0x94
,,,       .equ   SIGNATURE_002   = 0x03
,,,       
,,,       #pragma AVRPART CORE CORE_VERSION V2E
,,,       
,,,       
,,,       ; ***** I/O REGISTER DEFINITIONS *****************************************
,,,       ; NOTE:
,,,       ; Definitions marked "MEMORY MAPPED"are extended I/O ports
,,,       ; and cannot be used with IN/OUT instructions
,,,       .equ   SREG    = 0x3f
,,,       .equ   SPL     = 0x3d
,,,       .equ   SPH     = 0x3e
,,,       .equ   OCR0    = 0x3c
,,,       .equ   GICR    = 0x3b
,,,       .equ   GIFR    = 0x3a
,,,       .equ   TIMSK   = 0x39
,,,       .equ   TIFR    = 0x38
,,,       .equ   SPMCSR  = 0x37
,,,       .equ   TWCR    = 0x36
,,,       .equ   MCUCR   = 0x35
,,,       .equ   MCUCSR  = 0x34
,,,       .equ   TCCR0   = 0x33
,,,       .equ   TCNT0   = 0x32
,,,       .equ   OSCCAL  = 0x31
,,,       .equ   OCDR    = 0x31
,,,       .equ   SFIOR   = 0x30
,,,       .equ   TCCR1A  = 0x2f
,,,       .equ   TCCR1B  = 0x2e
,,,       .equ   TCNT1L  = 0x2c
,,,       .equ   TCNT1H  = 0x2d
,,,       .equ   OCR1AL  = 0x2a
,,,       .equ   OCR1AH  = 0x2b
,,,       .equ   OCR1BL  = 0x28
,,,       .equ   OCR1BH  = 0x29
,,,       .equ   ICR1L   = 0x26
,,,       .equ   ICR1H   = 0x27
,,,       .equ   TCCR2   = 0x25
,,,       .equ   TCNT2   = 0x24
,,,       .equ   OCR2    = 0x23
,,,       .equ   ASSR    = 0x22
,,,       .equ   WDTCR   = 0x21
,,,       .equ   UBRRH   = 0x20
,,,       .equ   UCSRC   = 0x20
,,,       .equ   EEARL   = 0x1e
,,,       .equ   EEARH   = 0x1f
,,,       .equ   EEDR    = 0x1d
,,,       .equ   EECR    = 0x1c
,,,       .equ   PORTA   = 0x1b
,,,       .equ   DDRA    = 0x1a
,,,       .equ   PINA    = 0x19
,,,       .equ   PORTB   = 0x18
,,,       .equ   DDRB    = 0x17
,,,       .equ   PINB    = 0x16
,,,       .equ   PORTC   = 0x15
,,,       .equ   DDRC    = 0x14
,,,       .equ   PINC    = 0x13
,,,       .equ   PORTD   = 0x12
,,,       .equ   DDRD    = 0x11
,,,       .equ   PIND    = 0x10
,,,       .equ   SPDR    = 0x0f
,,,       .equ   SPSR    = 0x0e
,,,       .equ   SPCR    = 0x0d
,,,       .equ   UDR     = 0x0c
,,,       .equ   UCSRA   = 0x0b
,,,       .equ   UCSRB   = 0x0a
,,,       .equ   UBRRL   = 0x09
,,,       .equ   ACSR    = 0x08
,,,       .equ   ADMUX   = 0x07
,,,       .equ   ADCSRA  = 0x06
,,,       .equ   ADCH    = 0x05
,,,       .equ   ADCL    = 0x04
,,,       .equ   TWDR    = 0x03
,,,       .equ   TWAR    = 0x02
,,,       .equ   TWSR    = 0x01
,,,       .equ   TWBR    = 0x00
,,,       
,,,       
,,,       ; ***** BIT DEFINITIONS **************************************************
,,,       
,,,       ; ***** TIMER_COUNTER_0 **************
,,,       ; TCCR0 - Timer/Counter Control Register
,,,       .equ   CS00    = 0     ; Clock Select 1
,,,       .equ   CS01    = 1     ; Clock Select 1
,,,       .equ   CS02    = 2     ; Clock Select 2
,,,       .equ   WGM01   = 3     ; Waveform Generation Mode 1
,,,       .equ   CTC0    = WGM01 ; For compatibility
,,,       .equ   COM00   = 4     ; Compare match Output Mode 0
,,,       .equ   COM01   = 5     ; Compare Match Output Mode 1
,,,       .equ   WGM00   = 6     ; Waveform Generation Mode 0
,,,       .equ   PWM0    = WGM00 ; For compatibility
,,,       .equ   FOC0    = 7     ; Force Output Compare
,,,       
,,,       ; TCNT0 - Timer/Counter Register
,,,       .equ   TCNT0_0 = 0     ; 
,,,       .equ   TCNT0_1 = 1     ; 
,,,       .equ   TCNT0_2 = 2     ; 
,,,       .equ   TCNT0_3 = 3     ; 
,,,       .equ   TCNT0_4 = 4     ; 
,,,       .equ   TCNT0_5 = 5     ; 
,,,       .equ   TCNT0_6 = 6     ; 
,,,       .equ   TCNT0_7 = 7     ; 
,,,       
,,,       ; OCR0 - Output Compare Register
,,,       .equ   OCR0_0  = 0     ; 
,,,       .equ   OCR0_1  = 1     ; 
,,,       .equ   OCR0_2  = 2     ; 
,,,       .equ   OCR0_3  = 3     ; 
,,,       .equ   OCR0_4  = 4     ; 
,,,       .equ   OCR0_5  = 5     ; 
,,,       .equ   OCR0_6  = 6     ; 
,,,       .equ   OCR0_7  = 7     ; 
,,,       
,,,       ; TIMSK - Timer/Counter Interrupt Mask Register
,,,       .equ   TOIE0   = 0     ; Timer/Counter0 Overflow Interrupt Enable
,,,       .equ   OCIE0   = 1     ; Timer/Counter0 Output Compare Match Interrupt register
,,,       
,,,       ; TIFR - Timer/Counter Interrupt Flag register
,,,       .equ   TOV0    = 0     ; Timer/Counter0 Overflow Flag
,,,       .equ   OCF0    = 1     ; Output Compare Flag 0
,,,       
,,,       ; SFIOR - Special Function IO Register
,,,       .equ   PSR10   = 0     ; Prescaler Reset Timer/Counter1 and Timer/Counter0
,,,       
,,,       
,,,       ; ***** TIMER_COUNTER_1 **************
,,,       ; TIMSK - Timer/Counter Interrupt Mask Register
,,,       .equ   TOIE1   = 2     ; Timer/Counter1 Overflow Interrupt Enable
,,,       .equ   OCIE1B  = 3     ; Timer/Counter1 Output CompareB Match Interrupt Enable
,,,       .equ   OCIE1A  = 4     ; Timer/Counter1 Output CompareA Match Interrupt Enable
,,,       .equ   TICIE1  = 5     ; Timer/Counter1 Input Capture Interrupt Enable
,,,       
,,,       ; TIFR - Timer/Counter Interrupt Flag register
,,,       .equ   TOV1    = 2     ; Timer/Counter1 Overflow Flag
,,,       .equ   OCF1B   = 3     ; Output Compare Flag 1B
,,,       .equ   OCF1A   = 4     ; Output Compare Flag 1A
,,,       .equ   ICF1    = 5     ; Input Capture Flag 1
,,,       
,,,       ; TCCR1A - Timer/Counter1 Control Register A
,,,       .equ   WGM10   = 0     ; Waveform Generation Mode
,,,       .equ   PWM10   = WGM10 ; For compatibility
,,,       .equ   WGM11   = 1     ; Waveform Generation Mode
,,,       .equ   PWM11   = WGM11 ; For compatibility
,,,       .equ   FOC1B   = 2     ; Force Output Compare 1B
,,,       .equ   FOC1A   = 3     ; Force Output Compare 1A
,,,       .equ   COM1B0  = 4     ; Compare Output Mode 1B, bit 0
,,,       .equ   COM1B1  = 5     ; Compare Output Mode 1B, bit 1
,,,       .equ   COM1A0  = 6     ; Compare Ouput Mode 1A, bit 0
,,,       .equ   COM1A1  = 7     ; Compare Output Mode 1A, bit 1
,,,       
,,,       ; TCCR1B - Timer/Counter1 Control Register B
,,,       .equ   CS10    = 0     ; Prescaler source of Timer/Counter 1
,,,       .equ   CS11    = 1     ; Prescaler source of Timer/Counter 1
,,,       .equ   CS12    = 2     ; Prescaler source of Timer/Counter 1
,,,       .equ   WGM12   = 3     ; Waveform Generation Mode
,,,       .equ   CTC10   = WGM12 ; For compatibility
,,,       .equ   CTC1    = WGM12 ; For compatibility
,,,       .equ   WGM13   = 4     ; Waveform Generation Mode
,,,       .equ   CTC11   = WGM13 ; For compatibility
,,,       .equ   ICES1   = 6     ; Input Capture 1 Edge Select
,,,       .equ   ICNC1   = 7     ; Input Capture 1 Noise Canceler
,,,       
,,,       
,,,       ; ***** EXTERNAL_INTERRUPT ***********
,,,       ; GICR - General Interrupt Control Register
,,,       .equ   GIMSK   = GICR  ; For compatibility
,,,       .equ   IVCE    = 0     ; Interrupt Vector Change Enable
,,,       .equ   IVSEL   = 1     ; Interrupt Vector Select
,,,       .equ   INT2    = 5     ; External Interrupt Request 2 Enable
,,,       .equ   INT0    = 6     ; External Interrupt Request 0 Enable
,,,       .equ   INT1    = 7     ; External Interrupt Request 1 Enable
,,,       
,,,       ; GIFR - General Interrupt Flag Register
,,,       .equ   INTF2   = 5     ; External Interrupt Flag 2
,,,       .equ   INTF0   = 6     ; External Interrupt Flag 0
,,,       .equ   INTF1   = 7     ; External Interrupt Flag 1
,,,       
,,,       ; MCUCR - General Interrupt Control Register
,,,       .equ   ISC00   = 0     ; Interrupt Sense Control 0 Bit 0
,,,       .equ   ISC01   = 1     ; Interrupt Sense Control 0 Bit 1
,,,       .equ   ISC10   = 2     ; Interrupt Sense Control 1 Bit 0
,,,       .equ   ISC11   = 3     ; Interrupt Sense Control 1 Bit 1
,,,       
,,,       ; MCUCSR - MCU Control And Status Register
,,,       .equ   ISC2    = 6     ; Interrupt Sense Control 2
,,,       
,,,       
,,,       ; ***** EEPROM ***********************
,,,       ; EEDR - EEPROM Data Register
,,,       .equ   EEDR0   = 0     ; EEPROM Data Register bit 0
,,,       .equ   EEDR1   = 1     ; EEPROM Data Register bit 1
,,,       .equ   EEDR2   = 2     ; EEPROM Data Register bit 2
,,,       .equ   EEDR3   = 3     ; EEPROM Data Register bit 3
,,,       .equ   EEDR4   = 4     ; EEPROM Data Register bit 4
,,,       .equ   EEDR5   = 5     ; EEPROM Data Register bit 5
,,,       .equ   EEDR6   = 6     ; EEPROM Data Register bit 6
,,,       .equ   EEDR7   = 7     ; EEPROM Data Register bit 7
,,,       
,,,       ; EECR - EEPROM Control Register
,,,       .equ   EERE    = 0     ; EEPROM Read Enable
,,,       .equ   EEWE    = 1     ; EEPROM Write Enable
,,,       .equ   EEMWE   = 2     ; EEPROM Master Write Enable
,,,       .equ   EEWEE   = EEMWE ; For compatibility
,,,       .equ   EERIE   = 3     ; EEPROM Ready Interrupt Enable
,,,       
,,,       
,,,       ; ***** CPU **************************
,,,       ; SREG - Status Register
,,,       .equ   SREG_C  = 0     ; Carry Flag
,,,       .equ   SREG_Z  = 1     ; Zero Flag
,,,       .equ   SREG_N  = 2     ; Negative Flag
,,,       .equ   SREG_V  = 3     ; Two's Complement Overflow Flag
,,,       .equ   SREG_S  = 4     ; Sign Bit
,,,       .equ   SREG_H  = 5     ; Half Carry Flag
,,,       .equ   SREG_T  = 6     ; Bit Copy Storage
,,,       .equ   SREG_I  = 7     ; Global Interrupt Enable
,,,       
,,,       ; MCUCR - MCU Control Register
,,,       ;.equ  ISC00   = 0     ; Interrupt Sense Control 0 Bit 0
,,,       ;.equ  ISC01   = 1     ; Interrupt Sense Control 0 Bit 1
,,,       ;.equ  ISC10   = 2     ; Interrupt Sense Control 1 Bit 0
,,,       ;.equ  ISC11   = 3     ; Interrupt Sense Control 1 Bit 1
,,,       .equ   SM0     = 4     ; Sleep Mode Select
,,,       .equ   SM1     = 5     ; Sleep Mode Select
,,,       .equ   SE      = 6     ; Sleep Enable
,,,       .equ   SM2     = 7     ; Sleep Mode Select
,,,       
,,,       ; MCUCSR - MCU Control And Status Register
,,,       .equ   MCUSR   = MCUCSR        ; For compatibility
,,,       .equ   PORF    = 0     ; Power-on reset flag
,,,       .equ   EXTRF   = 1     ; External Reset Flag
,,,       .equ   EXTREF  = EXTRF ; For compatibility
,,,       .equ   BORF    = 2     ; Brown-out Reset Flag
,,,       .equ   WDRF    = 3     ; Watchdog Reset Flag
,,,       .equ   JTRF    = 4     ; JTAG Reset Flag
,,,       .equ   JTD     = 7     ; JTAG Interface Disable
,,,       
,,,       ; OSCCAL - Oscillator Calibration Value
,,,       .equ   CAL0    = 0     ; Oscillator Calibration Value Bit0
,,,       .equ   CAL1    = 1     ; Oscillator Calibration Value Bit1
,,,       .equ   CAL2    = 2     ; Oscillator Calibration Value Bit2
,,,       .equ   CAL3    = 3     ; Oscillator Calibration Value Bit3
,,,       .equ   CAL4    = 4     ; Oscillator Calibration Value Bit4
,,,       .equ   CAL5    = 5     ; Oscillator Calibration Value Bit5
,,,       .equ   CAL6    = 6     ; Oscillator Calibration Value Bit6
,,,       .equ   CAL7    = 7     ; Oscillator Calibration Value Bit7
,,,       
,,,       ; SFIOR - Special function I/O register
,,,       ;.equ  PSR10   = 0     ; Prescaler reset
,,,       .equ   PSR2    = 1     ; Prescaler reset
,,,       .equ   PUD     = 2     ; Pull-up Disable
,,,       
,,,       
,,,       ; ***** TIMER_COUNTER_2 **************
,,,       ; TIMSK - Timer/Counter Interrupt Mask register
,,,       .equ   TOIE2   = 6     ; Timer/Counter2 Overflow Interrupt Enable
,,,       .equ   OCIE2   = 7     ; Timer/Counter2 Output Compare Match Interrupt Enable
,,,       
,,,       ; TIFR - Timer/Counter Interrupt Flag Register
,,,       .equ   TOV2    = 6     ; Timer/Counter2 Overflow Flag
,,,       .equ   OCF2    = 7     ; Output Compare Flag 2
,,,       
,,,       ; TCCR2 - Timer/Counter2 Control Register
,,,       .equ   CS20    = 0     ; Clock Select bit 0
,,,       .equ   CS21    = 1     ; Clock Select bit 1
,,,       .equ   CS22    = 2     ; Clock Select bit 2
,,,       .equ   WGM21   = 3     ; Waveform Generation Mode
,,,       .equ   CTC2    = WGM21 ; For compatibility
,,,       .equ   COM20   = 4     ; Compare Output Mode bit 0
,,,       .equ   COM21   = 5     ; Compare Output Mode bit 1
,,,       .equ   WGM20   = 6     ; Waveform Genration Mode
,,,       .equ   PWM2    = WGM20 ; For compatibility
,,,       .equ   FOC2    = 7     ; Force Output Compare
,,,       
,,,       ; TCNT2 - Timer/Counter2
,,,       .equ   TCNT2_0 = 0     ; Timer/Counter 2 bit 0
,,,       .equ   TCNT2_1 = 1     ; Timer/Counter 2 bit 1
,,,       .equ   TCNT2_2 = 2     ; Timer/Counter 2 bit 2
,,,       .equ   TCNT2_3 = 3     ; Timer/Counter 2 bit 3
,,,       .equ   TCNT2_4 = 4     ; Timer/Counter 2 bit 4
,,,       .equ   TCNT2_5 = 5     ; Timer/Counter 2 bit 5
,,,       .equ   TCNT2_6 = 6     ; Timer/Counter 2 bit 6
,,,       .equ   TCNT2_7 = 7     ; Timer/Counter 2 bit 7
,,,       
,,,       ; OCR2 - Timer/Counter2 Output Compare Register
,,,       .equ   OCR2_0  = 0     ; Timer/Counter2 Output Compare Register Bit 0
,,,       .equ   OCR2_1  = 1     ; Timer/Counter2 Output Compare Register Bit 1
,,,       .equ   OCR2_2  = 2     ; Timer/Counter2 Output Compare Register Bit 2
,,,       .equ   OCR2_3  = 3     ; Timer/Counter2 Output Compare Register Bit 3
,,,       .equ   OCR2_4  = 4     ; Timer/Counter2 Output Compare Register Bit 4
,,,       .equ   OCR2_5  = 5     ; Timer/Counter2 Output Compare Register Bit 5
,,,       .equ   OCR2_6  = 6     ; Timer/Counter2 Output Compare Register Bit 6
,,,       .equ   OCR2_7  = 7     ; Timer/Counter2 Output Compare Register Bit 7
,,,       
,,,       ; ASSR - Asynchronous Status Register
,,,       .equ   TCR2UB  = 0     ; Timer/counter Control Register2 Update Busy
,,,       .equ   OCR2UB  = 1     ; Output Compare Register2 Update Busy
,,,       .equ   TCN2UB  = 2     ; Timer/Counter2 Update Busy
,,,       .equ   AS2     = 3     ; Asynchronous Timer/counter2
,,,       
,,,       ; SFIOR - Special Function IO Register
,,,       ;.equ  PSR2    = 1     ; Prescaler Reset Timer/Counter2
,,,       
,,,       
,,,       ; ***** SPI **************************
,,,       ; SPDR - SPI Data Register
,,,       .equ   SPDR0   = 0     ; SPI Data Register bit 0
,,,       .equ   SPDR1   = 1     ; SPI Data Register bit 1
,,,       .equ   SPDR2   = 2     ; SPI Data Register bit 2
,,,       .equ   SPDR3   = 3     ; SPI Data Register bit 3
,,,       .equ   SPDR4   = 4     ; SPI Data Register bit 4
,,,       .equ   SPDR5   = 5     ; SPI Data Register bit 5
,,,       .equ   SPDR6   = 6     ; SPI Data Register bit 6
,,,       .equ   SPDR7   = 7     ; SPI Data Register bit 7
,,,       
,,,       ; SPSR - SPI Status Register
,,,       .equ   SPI2X   = 0     ; Double SPI Speed Bit
,,,       .equ   WCOL    = 6     ; Write Collision Flag
,,,       .equ   SPIF    = 7     ; SPI Interrupt Flag
,,,       
,,,       ; SPCR - SPI Control Register
,,,       .equ   SPR0    = 0     ; SPI Clock Rate Select 0
,,,       .equ   SPR1    = 1     ; SPI Clock Rate Select 1
,,,       .equ   CPHA    = 2     ; Clock Phase
,,,       .equ   CPOL    = 3     ; Clock polarity
,,,       .equ   MSTR    = 4     ; Master/Slave Select
,,,       .equ   DORD    = 5     ; Data Order
,,,       .equ   SPE     = 6     ; SPI Enable
,,,       .equ   SPIE    = 7     ; SPI Interrupt Enable
,,,       
,,,       
,,,       ; ***** USART ************************
,,,       ; UDR - USART I/O Data Register
,,,       .equ   UDR0    = 0     ; USART I/O Data Register bit 0
,,,       .equ   UDR1    = 1     ; USART I/O Data Register bit 1
,,,       .equ   UDR2    = 2     ; USART I/O Data Register bit 2
,,,       .equ   UDR3    = 3     ; USART I/O Data Register bit 3
,,,       .equ   UDR4    = 4     ; USART I/O Data Register bit 4
,,,       .equ   UDR5    = 5     ; USART I/O Data Register bit 5
,,,       .equ   UDR6    = 6     ; USART I/O Data Register bit 6
,,,       .equ   UDR7    = 7     ; USART I/O Data Register bit 7
,,,       
,,,       ; UCSRA - USART Control and Status Register A
,,,       .equ   USR     = UCSRA ; For compatibility
,,,       .equ   MPCM    = 0     ; Multi-processor Communication Mode
,,,       .equ   U2X     = 1     ; Double the USART transmission speed
,,,       .equ   UPE     = 2     ; Parity Error
,,,       .equ   PE      = UPE   ; For compatibility
,,,       .equ   DOR     = 3     ; Data overRun
,,,       .equ   FE      = 4     ; Framing Error
,,,       .equ   UDRE    = 5     ; USART Data Register Empty
,,,       .equ   TXC     = 6     ; USART Transmitt Complete
,,,       .equ   RXC     = 7     ; USART Receive Complete
,,,       
,,,       ; UCSRB - USART Control and Status Register B
,,,       .equ   UCR     = UCSRB ; For compatibility
,,,       .equ   TXB8    = 0     ; Transmit Data Bit 8
,,,       .equ   RXB8    = 1     ; Receive Data Bit 8
,,,       .equ   UCSZ2   = 2     ; Character Size
,,,       .equ   CHR9    = UCSZ2 ; For compatibility
,,,       .equ   TXEN    = 3     ; Transmitter Enable
,,,       .equ   RXEN    = 4     ; Receiver Enable
,,,       .equ   UDRIE   = 5     ; USART Data register Empty Interrupt Enable
,,,       .equ   TXCIE   = 6     ; TX Complete Interrupt Enable
,,,       .equ   RXCIE   = 7     ; RX Complete Interrupt Enable
,,,       
,,,       ; UCSRC - USART Control and Status Register C
,,,       .equ   UCPOL   = 0     ; Clock Polarity
,,,       .equ   UCSZ0   = 1     ; Character Size
,,,       .equ   UCSZ1   = 2     ; Character Size
,,,       .equ   USBS    = 3     ; Stop Bit Select
,,,       .equ   UPM0    = 4     ; Parity Mode Bit 0
,,,       .equ   UPM1    = 5     ; Parity Mode Bit 1
,,,       .equ   UMSEL   = 6     ; USART Mode Select
,,,       .equ   URSEL   = 7     ; Register Select
,,,       
,,,       .equ   UBRRHI  = UBRRH ; For compatibility
,,,       
,,,       ; ***** TWI **************************
,,,       ; TWBR - TWI Bit Rate register
,,,       .equ   I2BR    = TWBR  ; For compatibility
,,,       .equ   TWBR0   = 0     ; 
,,,       .equ   TWBR1   = 1     ; 
,,,       .equ   TWBR2   = 2     ; 
,,,       .equ   TWBR3   = 3     ; 
,,,       .equ   TWBR4   = 4     ; 
,,,       .equ   TWBR5   = 5     ; 
,,,       .equ   TWBR6   = 6     ; 
,,,       .equ   TWBR7   = 7     ; 
,,,       
,,,       ; TWCR - TWI Control Register
,,,       .equ   I2CR    = TWCR  ; For compatibility
,,,       .equ   TWIE    = 0     ; TWI Interrupt Enable
,,,       .equ   I2IE    = TWIE  ; For compatibility
,,,       .equ   TWEN    = 2     ; TWI Enable Bit
,,,       .equ   I2EN    = TWEN  ; For compatibility
,,,       .equ   ENI2C   = TWEN  ; For compatibility
,,,       .equ   TWWC    = 3     ; TWI Write Collition Flag
,,,       .equ   I2WC    = TWWC  ; For compatibility
,,,       .equ   TWSTO   = 4     ; TWI Stop Condition Bit
,,,       .equ   I2STO   = TWSTO ; For compatibility
,,,       .equ   TWSTA   = 5     ; TWI Start Condition Bit
,,,       .equ   I2STA   = TWSTA ; For compatibility
,,,       .equ   TWEA    = 6     ; TWI Enable Acknowledge Bit
,,,       .equ   I2EA    = TWEA  ; For compatibility
,,,       .equ   TWINT   = 7     ; TWI Interrupt Flag
,,,       .equ   I2INT   = TWINT ; For compatibility
,,,       
,,,       ; TWSR - TWI Status Register
,,,       .equ   I2SR    = TWSR  ; For compatibility
,,,       .equ   TWPS0   = 0     ; TWI Prescaler
,,,       .equ   TWS0    = TWPS0 ; For compatibility
,,,       .equ   I2GCE   = TWPS0 ; For compatibility
,,,       .equ   TWPS1   = 1     ; TWI Prescaler
,,,       .equ   TWS1    = TWPS1 ; For compatibility
,,,       .equ   TWS3    = 3     ; TWI Status
,,,       .equ   I2S3    = TWS3  ; For compatibility
,,,       .equ   TWS4    = 4     ; TWI Status
,,,       .equ   I2S4    = TWS4  ; For compatibility
,,,       .equ   TWS5    = 5     ; TWI Status
,,,       .equ   I2S5    = TWS5  ; For compatibility
,,,       .equ   TWS6    = 6     ; TWI Status
,,,       .equ   I2S6    = TWS6  ; For compatibility
,,,       .equ   TWS7    = 7     ; TWI Status
,,,       .equ   I2S7    = TWS7  ; For compatibility
,,,       
,,,       ; TWDR - TWI Data register
,,,       .equ   I2DR    = TWDR  ; For compatibility
,,,       .equ   TWD0    = 0     ; TWI Data Register Bit 0
,,,       .equ   TWD1    = 1     ; TWI Data Register Bit 1
,,,       .equ   TWD2    = 2     ; TWI Data Register Bit 2
,,,       .equ   TWD3    = 3     ; TWI Data Register Bit 3
,,,       .equ   TWD4    = 4     ; TWI Data Register Bit 4
,,,       .equ   TWD5    = 5     ; TWI Data Register Bit 5
,,,       .equ   TWD6    = 6     ; TWI Data Register Bit 6
,,,       .equ   TWD7    = 7     ; TWI Data Register Bit 7
,,,       
,,,       ; TWAR - TWI (Slave) Address register
,,,       .equ   I2AR    = TWAR  ; For compatibility
,,,       .equ   TWGCE   = 0     ; TWI General Call Recognition Enable Bit
,,,       .equ   TWA0    = 1     ; TWI (Slave) Address register Bit 0
,,,       .equ   TWA1    = 2     ; TWI (Slave) Address register Bit 1
,,,       .equ   TWA2    = 3     ; TWI (Slave) Address register Bit 2
,,,       .equ   TWA3    = 4     ; TWI (Slave) Address register Bit 3
,,,       .equ   TWA4    = 5     ; TWI (Slave) Address register Bit 4
,,,       .equ   TWA5    = 6     ; TWI (Slave) Address register Bit 5
,,,       .equ   TWA6    = 7     ; TWI (Slave) Address register Bit 6
,,,       
,,,       
,,,       ; ***** ANALOG_COMPARATOR ************
,,,       ; SFIOR - Special Function IO Register
,,,       .equ   ACME    = 3     ; Analog Comparator Multiplexer Enable
,,,       
,,,       ; ACSR - Analog Comparator Control And Status Register
,,,       .equ   ACIS0   = 0     ; Analog Comparator Interrupt Mode Select bit 0
,,,       .equ   ACIS1   = 1     ; Analog Comparator Interrupt Mode Select bit 1
,,,       .equ   ACIC    = 2     ; Analog Comparator Input Capture Enable
,,,       .equ   ACIE    = 3     ; Analog Comparator Interrupt Enable
,,,       .equ   ACI     = 4     ; Analog Comparator Interrupt Flag
,,,       .equ   ACO     = 5     ; Analog Compare Output
,,,       .equ   ACBG    = 6     ; Analog Comparator Bandgap Select
,,,       .equ   ACD     = 7     ; Analog Comparator Disable
,,,       
,,,       
,,,       ; ***** AD_CONVERTER *****************
,,,       ; ADMUX - The ADC multiplexer Selection Register
,,,       .equ   MUX0    = 0     ; Analog Channel and Gain Selection Bits
,,,       .equ   MUX1    = 1     ; Analog Channel and Gain Selection Bits
,,,       .equ   MUX2    = 2     ; Analog Channel and Gain Selection Bits
,,,       .equ   MUX3    = 3     ; Analog Channel and Gain Selection Bits
,,,       .equ   MUX4    = 4     ; Analog Channel and Gain Selection Bits
,,,       .equ   ADLAR   = 5     ; Left Adjust Result
,,,       .equ   REFS0   = 6     ; Reference Selection Bit 0
,,,       .equ   REFS1   = 7     ; Reference Selection Bit 1
,,,       
,,,       ; ADCSRA - The ADC Control and Status register
,,,       .equ   ADCSR   = ADCSRA        ; For compatibility
,,,       .equ   ADPS0   = 0     ; ADC  Prescaler Select Bits
,,,       .equ   ADPS1   = 1     ; ADC  Prescaler Select Bits
,,,       .equ   ADPS2   = 2     ; ADC  Prescaler Select Bits
,,,       .equ   ADIE    = 3     ; ADC Interrupt Enable
,,,       .equ   ADIF    = 4     ; ADC Interrupt Flag
,,,       .equ   ADATE   = 5     ; When this bit is written to one,the Timer/Counter2 prescaler will be reset.The bit will be cleared by hardware after the operation is performed.Writing a zero to this bit will have no effect.This bit will always be read as zero if Timer/C                 ounter2 is clocked by the internal CPU clock.If this bit is written when Timer/Counter2 is operating in asynchronous mode,the bit will remain one until the prescaler has been reset.
,,,       .equ   ADFR    = ADATE ; For compatibility
,,,       .equ   ADSC    = 6     ; ADC Start Conversion
,,,       .equ   ADEN    = 7     ; ADC Enable
,,,       
,,,       ; ADCH - ADC Data Register High Byte
,,,       .equ   ADCH0   = 0     ; ADC Data Register High Byte Bit 0
,,,       .equ   ADCH1   = 1     ; ADC Data Register High Byte Bit 1
,,,       .equ   ADCH2   = 2     ; ADC Data Register High Byte Bit 2
,,,       .equ   ADCH3   = 3     ; ADC Data Register High Byte Bit 3
,,,       .equ   ADCH4   = 4     ; ADC Data Register High Byte Bit 4
,,,       .equ   ADCH5   = 5     ; ADC Data Register High Byte Bit 5
,,,       .equ   ADCH6   = 6     ; ADC Data Register High Byte Bit 6
,,,       .equ   ADCH7   = 7     ; ADC Data Register High Byte Bit 7
,,,       
,,,       ; ADCL - ADC Data Register Low Byte
,,,       .equ   ADCL0   = 0     ; ADC Data Register Low Byte Bit 0
,,,       .equ   ADCL1   = 1     ; ADC Data Register Low Byte Bit 1
,,,       .equ   ADCL2   = 2     ; ADC Data Register Low Byte Bit 2
,,,       .equ   ADCL3   = 3     ; ADC Data Register Low Byte Bit 3
,,,       .equ   ADCL4   = 4     ; ADC Data Register Low Byte Bit 4
,,,       .equ   ADCL5   = 5     ; ADC Data Register Low Byte Bit 5
,,,       .equ   ADCL6   = 6     ; ADC Data Register Low Byte Bit 6
,,,       .equ   ADCL7   = 7     ; ADC Data Register Low Byte Bit 7
,,,       
,,,       ; SFIOR - Special Function IO Register
,,,       .equ   ADTS0   = 5     ; ADC Auto Trigger Source 0
,,,       .equ   ADTS1   = 6     ; ADC Auto Trigger Source 1
,,,       .equ   ADTS2   = 7     ; ADC Auto Trigger Source 2
,,,       
,,,       
,,,       ; ***** JTAG *************************
,,,       ; OCDR - On-Chip Debug Related Register in I/O Memory
,,,       .equ   OCDR0   = 0     ; On-Chip Debug Register Bit 0
,,,       .equ   OCDR1   = 1     ; On-Chip Debug Register Bit 1
,,,       .equ   OCDR2   = 2     ; On-Chip Debug Register Bit 2
,,,       .equ   OCDR3   = 3     ; On-Chip Debug Register Bit 3
,,,       .equ   OCDR4   = 4     ; On-Chip Debug Register Bit 4
,,,       .equ   OCDR5   = 5     ; On-Chip Debug Register Bit 5
,,,       .equ   OCDR6   = 6     ; On-Chip Debug Register Bit 6
,,,       .equ   OCDR7   = 7     ; On-Chip Debug Register Bit 7
,,,       .equ   IDRD    = OCDR7 ; For compatibility
,,,       
,,,       ; MCUCSR - MCU Control And Status Register
,,,       ;.equ  JTRF    = 4     ; JTAG Reset Flag
,,,       ;.equ  JTD     = 7     ; JTAG Interface Disable
,,,       
,,,       
,,,       ; ***** BOOT_LOAD ********************
,,,       ; SPMCSR - Store Program Memory Control Register
,,,       .equ   SPMCR   = SPMCSR        ; For compatibility
,,,       .equ   SPMEN   = 0     ; Store Program Memory Enable
,,,       .equ   PGERS   = 1     ; Page Erase
,,,       .equ   PGWRT   = 2     ; Page Write
,,,       .equ   BLBSET  = 3     ; Boot Lock Bit Set
,,,       .equ   RWWSRE  = 4     ; Read While Write section read enable
,,,       .equ   ASRE    = RWWSRE        ; For compatibility
,,,       .equ   RWWSB   = 6     ; Read While Write Section Busy
,,,       .equ   ASB     = RWWSB ; For compatibility
,,,       .equ   SPMIE   = 7     ; SPM Interrupt Enable
,,,       
,,,       
,,,       ; ***** PORTA ************************
,,,       ; PORTA - Port A Data Register
,,,       .equ   PORTA0  = 0     ; Port A Data Register bit 0
,,,       .equ   PA0     = 0     ; For compatibility
,,,       .equ   PORTA1  = 1     ; Port A Data Register bit 1
,,,       .equ   PA1     = 1     ; For compatibility
,,,       .equ   PORTA2  = 2     ; Port A Data Register bit 2
,,,       .equ   PA2     = 2     ; For compatibility
,,,       .equ   PORTA3  = 3     ; Port A Data Register bit 3
,,,       .equ   PA3     = 3     ; For compatibility
,,,       .equ   PORTA4  = 4     ; Port A Data Register bit 4
,,,       .equ   PA4     = 4     ; For compatibility
,,,       .equ   PORTA5  = 5     ; Port A Data Register bit 5
,,,       .equ   PA5     = 5     ; For compatibility
,,,       .equ   PORTA6  = 6     ; Port A Data Register bit 6
,,,       .equ   PA6     = 6     ; For compatibility
,,,       .equ   PORTA7  = 7     ; Port A Data Register bit 7
,,,       .equ   PA7     = 7     ; For compatibility
,,,       
,,,       ; DDRA - Port A Data Direction Register
,,,       .equ   DDA0    = 0     ; Data Direction Register, Port A, bit 0
,,,       .equ   DDA1    = 1     ; Data Direction Register, Port A, bit 1
,,,       .equ   DDA2    = 2     ; Data Direction Register, Port A, bit 2
,,,       .equ   DDA3    = 3     ; Data Direction Register, Port A, bit 3
,,,       .equ   DDA4    = 4     ; Data Direction Register, Port A, bit 4
,,,       .equ   DDA5    = 5     ; Data Direction Register, Port A, bit 5
,,,       .equ   DDA6    = 6     ; Data Direction Register, Port A, bit 6
,,,       .equ   DDA7    = 7     ; Data Direction Register, Port A, bit 7
,,,       
,,,       ; PINA - Port A Input Pins
,,,       .equ   PINA0   = 0     ; Input Pins, Port A bit 0
,,,       .equ   PINA1   = 1     ; Input Pins, Port A bit 1
,,,       .equ   PINA2   = 2     ; Input Pins, Port A bit 2
,,,       .equ   PINA3   = 3     ; Input Pins, Port A bit 3
,,,       .equ   PINA4   = 4     ; Input Pins, Port A bit 4
,,,       .equ   PINA5   = 5     ; Input Pins, Port A bit 5
,,,       .equ   PINA6   = 6     ; Input Pins, Port A bit 6
,,,       .equ   PINA7   = 7     ; Input Pins, Port A bit 7
,,,       
,,,       
,,,       ; ***** PORTB ************************
,,,       ; PORTB - Port B Data Register
,,,       .equ   PORTB0  = 0     ; Port B Data Register bit 0
,,,       .equ   PB0     = 0     ; For compatibility
,,,       .equ   PORTB1  = 1     ; Port B Data Register bit 1
,,,       .equ   PB1     = 1     ; For compatibility
,,,       .equ   PORTB2  = 2     ; Port B Data Register bit 2
,,,       .equ   PB2     = 2     ; For compatibility
,,,       .equ   PORTB3  = 3     ; Port B Data Register bit 3
,,,       .equ   PB3     = 3     ; For compatibility
,,,       .equ   PORTB4  = 4     ; Port B Data Register bit 4
,,,       .equ   PB4     = 4     ; For compatibility
,,,       .equ   PORTB5  = 5     ; Port B Data Register bit 5
,,,       .equ   PB5     = 5     ; For compatibility
,,,       .equ   PORTB6  = 6     ; Port B Data Register bit 6
,,,       .equ   PB6     = 6     ; For compatibility
,,,       .equ   PORTB7  = 7     ; Port B Data Register bit 7
,,,       .equ   PB7     = 7     ; For compatibility
,,,       
,,,       ; DDRB - Port B Data Direction Register
,,,       .equ   DDB0    = 0     ; Port B Data Direction Register bit 0
,,,       .equ   DDB1    = 1     ; Port B Data Direction Register bit 1
,,,       .equ   DDB2    = 2     ; Port B Data Direction Register bit 2
,,,       .equ   DDB3    = 3     ; Port B Data Direction Register bit 3
,,,       .equ   DDB4    = 4     ; Port B Data Direction Register bit 4
,,,       .equ   DDB5    = 5     ; Port B Data Direction Register bit 5
,,,       .equ   DDB6    = 6     ; Port B Data Direction Register bit 6
,,,       .equ   DDB7    = 7     ; Port B Data Direction Register bit 7
,,,       
,,,       ; PINB - Port B Input Pins
,,,       .equ   PINB0   = 0     ; Port B Input Pins bit 0
,,,       .equ   PINB1   = 1     ; Port B Input Pins bit 1
,,,       .equ   PINB2   = 2     ; Port B Input Pins bit 2
,,,       .equ   PINB3   = 3     ; Port B Input Pins bit 3
,,,       .equ   PINB4   = 4     ; Port B Input Pins bit 4
,,,       .equ   PINB5   = 5     ; Port B Input Pins bit 5
,,,       .equ   PINB6   = 6     ; Port B Input Pins bit 6
,,,       .equ   PINB7   = 7     ; Port B Input Pins bit 7
,,,       
,,,       
,,,       ; ***** PORTC ************************
,,,       ; PORTC - Port C Data Register
,,,       .equ   PORTC0  = 0     ; Port C Data Register bit 0
,,,       .equ   PC0     = 0     ; For compatibility
,,,       .equ   PORTC1  = 1     ; Port C Data Register bit 1
,,,       .equ   PC1     = 1     ; For compatibility
,,,       .equ   PORTC2  = 2     ; Port C Data Register bit 2
,,,       .equ   PC2     = 2     ; For compatibility
,,,       .equ   PORTC3  = 3     ; Port C Data Register bit 3
,,,       .equ   PC3     = 3     ; For compatibility
,,,       .equ   PORTC4  = 4     ; Port C Data Register bit 4
,,,       .equ   PC4     = 4     ; For compatibility
,,,       .equ   PORTC5  = 5     ; Port C Data Register bit 5
,,,       .equ   PC5     = 5     ; For compatibility
,,,       .equ   PORTC6  = 6     ; Port C Data Register bit 6
,,,       .equ   PC6     = 6     ; For compatibility
,,,       .equ   PORTC7  = 7     ; Port C Data Register bit 7
,,,       .equ   PC7     = 7     ; For compatibility
,,,       
,,,       ; DDRC - Port C Data Direction Register
,,,       .equ   DDC0    = 0     ; Port C Data Direction Register bit 0
,,,       .equ   DDC1    = 1     ; Port C Data Direction Register bit 1
,,,       .equ   DDC2    = 2     ; Port C Data Direction Register bit 2
,,,       .equ   DDC3    = 3     ; Port C Data Direction Register bit 3
,,,       .equ   DDC4    = 4     ; Port C Data Direction Register bit 4
,,,       .equ   DDC5    = 5     ; Port C Data Direction Register bit 5
,,,       .equ   DDC6    = 6     ; Port C Data Direction Register bit 6
,,,       .equ   DDC7    = 7     ; Port C Data Direction Register bit 7
,,,       
,,,       ; PINC - Port C Input Pins
,,,       .equ   PINC0   = 0     ; Port C Input Pins bit 0
,,,       .equ   PINC1   = 1     ; Port C Input Pins bit 1
,,,       .equ   PINC2   = 2     ; Port C Input Pins bit 2
,,,       .equ   PINC3   = 3     ; Port C Input Pins bit 3
,,,       .equ   PINC4   = 4     ; Port C Input Pins bit 4
,,,       .equ   PINC5   = 5     ; Port C Input Pins bit 5
,,,       .equ   PINC6   = 6     ; Port C Input Pins bit 6
,,,       .equ   PINC7   = 7     ; Port C Input Pins bit 7
,,,       
,,,       
,,,       ; ***** PORTD ************************
,,,       ; PORTD - Port D Data Register
,,,       .equ   PORTD0  = 0     ; Port D Data Register bit 0
,,,       .equ   PD0     = 0     ; For compatibility
,,,       .equ   PORTD1  = 1     ; Port D Data Register bit 1
,,,       .equ   PD1     = 1     ; For compatibility
,,,       .equ   PORTD2  = 2     ; Port D Data Register bit 2
,,,       .equ   PD2     = 2     ; For compatibility
,,,       .equ   PORTD3  = 3     ; Port D Data Register bit 3
,,,       .equ   PD3     = 3     ; For compatibility
,,,       .equ   PORTD4  = 4     ; Port D Data Register bit 4
,,,       .equ   PD4     = 4     ; For compatibility
,,,       .equ   PORTD5  = 5     ; Port D Data Register bit 5
,,,       .equ   PD5     = 5     ; For compatibility
,,,       .equ   PORTD6  = 6     ; Port D Data Register bit 6
,,,       .equ   PD6     = 6     ; For compatibility
,,,       .equ   PORTD7  = 7     ; Port D Data Register bit 7
,,,       .equ   PD7     = 7     ; For compatibility
,,,       
,,,       ; DDRD - Port D Data Direction Register
,,,       .equ   DDD0    = 0     ; Port D Data Direction Register bit 0
,,,       .equ   DDD1    = 1     ; Port D Data Direction Register bit 1
,,,       .equ   DDD2    = 2     ; Port D Data Direction Register bit 2
,,,       .equ   DDD3    = 3     ; Port D Data Direction Register bit 3
,,,       .equ   DDD4    = 4     ; Port D Data Direction Register bit 4
,,,       .equ   DDD5    = 5     ; Port D Data Direction Register bit 5
,,,       .equ   DDD6    = 6     ; Port D Data Direction Register bit 6
,,,       .equ   DDD7    = 7     ; Port D Data Direction Register bit 7
,,,       
,,,       ; PIND - Port D Input Pins
,,,       .equ   PIND0   = 0     ; Port D Input Pins bit 0
,,,       .equ   PIND1   = 1     ; Port D Input Pins bit 1
,,,       .equ   PIND2   = 2     ; Port D Input Pins bit 2
,,,       .equ   PIND3   = 3     ; Port D Input Pins bit 3
,,,       .equ   PIND4   = 4     ; Port D Input Pins bit 4
,,,       .equ   PIND5   = 5     ; Port D Input Pins bit 5
,,,       .equ   PIND6   = 6     ; Port D Input Pins bit 6
,,,       .equ   PIND7   = 7     ; Port D Input Pins bit 7
,,,       
,,,       
,,,       ; ***** WATCHDOG *********************
,,,       ; WDTCR - Watchdog Timer Control Register
,,,       .equ   WDP0    = 0     ; Watch Dog Timer Prescaler bit 0
,,,       .equ   WDP1    = 1     ; Watch Dog Timer Prescaler bit 1
,,,       .equ   WDP2    = 2     ; Watch Dog Timer Prescaler bit 2
,,,       .equ   WDE     = 3     ; Watch Dog Enable
,,,       .equ   WDTOE   = 4     ; RW
,,,       .equ   WDDE    = WDTOE ; For compatibility
,,,       
,,,       
,,,       
,,,       ; ***** LOCKSBITS ********************************************************
,,,       .equ   LB1     = 0     ; Lock bit
,,,       .equ   LB2     = 1     ; Lock bit
,,,       .equ   BLB01   = 2     ; Boot Lock bit
,,,       .equ   BLB02   = 3     ; Boot Lock bit
,,,       .equ   BLB11   = 4     ; Boot lock bit
,,,       .equ   BLB12   = 5     ; Boot lock bit
,,,       
,,,       
,,,       ; ***** FUSES ************************************************************
,,,       ; LOW fuse bits
,,,       .equ   CKSEL0  = 0     ; Select Clock Source
,,,       .equ   CKSEL1  = 1     ; Select Clock Source
,,,       .equ   CKSEL2  = 2     ; Select Clock Source
,,,       .equ   CKSEL3  = 3     ; Select Clock Source
,,,       .equ   SUT0    = 4     ; Select start-up time
,,,       .equ   SUT1    = 5     ; Select start-up time
,,,       .equ   BODEN   = 6     ; Brown out detector enable
,,,       .equ   BODLEVEL        = 7     ; Brown out detector trigger level
,,,       
,,,       ; HIGH fuse bits
,,,       .equ   BOOTRST = 0     ; Select Reset Vector
,,,       .equ   BOOTSZ0 = 1     ; Select Boot Size
,,,       .equ   BOOTSZ1 = 2     ; Select Boot Size
,,,       .equ   EESAVE  = 3     ; EEPROM memory is preserved through chip erase
,,,       .equ   CKOPT   = 4     ; Oscillator Options
,,,       .equ   SPIEN   = 5     ; Enable Serial programming and Data Downloading
,,,       .equ   JTAGEN  = 6     ; Enable JTAG
,,,       .equ   OCDEN   = 7     ; Enable OCD
,,,       
,,,       
,,,       
,,,       ; ***** CPU REGISTER DEFINITIONS *****************************************
,,,       .def   XH      = r27
,,,       .def   XL      = r26
,,,       .def   YH      = r29
,,,       .def   YL      = r28
,,,       .def   ZH      = r31
,,,       .def   ZL      = r30
,,,       
,,,       
,,,       
,,,       ; ***** DATA MEMORY DECLARATIONS *****************************************
,,,       .equ   FLASHEND        = 0x1fff        ; Note: Word address
,,,       .equ   IOEND   = 0x003f
,,,       .equ   SRAM_START      = 0x0060
,,,       .equ   SRAM_SIZE       = 1024
,,,       .equ   RAMEND  = 0x045f
,,,       .equ   XRAMEND = 0x0000
,,,       .equ   E2END   = 0x01ff
,,,       .equ   EEPROMEND       = 0x01ff
,,,       .equ   EEADRBITS       = 9
,,,       #pragma AVRPART MEMORY PROG_FLASH 16384
,,,       #pragma AVRPART MEMORY EEPROM 512
,,,       #pragma AVRPART MEMORY INT_SRAM SIZE 1024
,,,       #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
,,,       
,,,       
,,,       
,,,       ; ***** BOOTLOADER DECLARATIONS ******************************************
,,,       .equ   NRWW_START_ADDR = 0x1c00
,,,       .equ   NRWW_STOP_ADDR  = 0x1fff
,,,       .equ   RWW_START_ADDR  = 0x0
,,,       .equ   RWW_STOP_ADDR   = 0x1bff
,,,       .equ   PAGESIZE        = 64
,,,       .equ   FIRSTBOOTSTART  = 0x1f80
,,,       .equ   SECONDBOOTSTART = 0x1f00
,,,       .equ   THIRDBOOTSTART  = 0x1e00
,,,       .equ   FOURTHBOOTSTART = 0x1c00
,,,       .equ   SMALLBOOTSTART  = FIRSTBOOTSTART
,,,       .equ   LARGEBOOTSTART  = FOURTHBOOTSTART
,,,       
,,,       
,,,       
,,,       ; ***** INTERRUPT VECTORS ************************************************
,,,       .equ   INT0addr        = 0x0002        ; External Interrupt Request 0
,,,       .equ   INT1addr        = 0x0004        ; External Interrupt Request 1
,,,       .equ   OC2addr = 0x0006        ; Timer/Counter2 Compare Match
,,,       .equ   OVF2addr        = 0x0008        ; Timer/Counter2 Overflow
,,,       .equ   ICP1addr        = 0x000a        ; Timer/Counter1 Capture Event
,,,       .equ   OC1Aaddr        = 0x000c        ; Timer/Counter1 Compare Match A
,,,       .equ   OC1Baddr        = 0x000e        ; Timer/Counter1 Compare Match B
,,,       .equ   OVF1addr        = 0x0010        ; Timer/Counter1 Overflow
,,,       .equ   OVF0addr        = 0x0012        ; Timer/Counter0 Overflow
,,,       .equ   SPIaddr = 0x0014        ; Serial Transfer Complete
,,,       .equ   URXCaddr        = 0x0016        ; USART, Rx Complete
,,,       .equ   UDREaddr        = 0x0018        ; USART Data Register Empty
,,,       .equ   UTXCaddr        = 0x001a        ; USART, Tx Complete
,,,       .equ   ADCCaddr        = 0x001c        ; ADC Conversion Complete
,,,       .equ   ERDYaddr        = 0x001e        ; EEPROM Ready
,,,       .equ   ACIaddr = 0x0020        ; Analog Comparator
,,,       .equ   TWIaddr = 0x0022        ; 2-wire Serial Interface
,,,       .equ   INT2addr        = 0x0024        ; External Interrupt Request 2
,,,       .equ   OC0addr = 0x0026        ; Timer/Counter0 Compare Match
,,,       .equ   SPMRaddr        = 0x0028        ; Store Program Memory Ready
,,,       
,,,       .equ   INT_VECTORS_SIZE        = 42    ; size in words
,,,       
,,,       #endif  /* _M16DEF_INC_ */
,,,       
,,,       
,,,       
,,,       //Дефайны
,,,       .equ           START_ADDR              =               0x1E00                                  //Стартовый адрес загрузчика
,,,       
,,,       .equ           LISTEN_PORT             =               PORTB                                   //На каком порте слушать
,,,       .equ           LISTEN_DDR              =               DDRB                                    //Порт направления
,,,       .equ           LISTEN_PIN              =               PINB                                    //Порт ввода
,,,       .equ           LISTEN_BIT              =               0                                               //Какой бит слушать
,,,       
,,,       .equ           LED_PORT                =               PORTB                                   //На каком порту зажигать светодиод
,,,       .equ           LED_DDR                 =               DDRB                                    //Порт направления
,,,       .equ           LED_BIT                 =               1                                               //Какой бит выставлять в 1
,,,       
,,,       .equ           OSC_FREQ                =               16000000                                //Частота кварца
,,,       .equ           BAUDRATE                =               57600                                   //Скорость UART
,,,       .equ           BAUDDIVIDER     = OSC_FREQ / (16 * BAUDRATE) - 1        //Делитель для UART
,,,       
,,,       .equ           ERR_OK                  =               0x00                                    //Нет ошибки
,,,       .equ           ERR_FAIL                =               0x01                                    //Ошибка
,,,       
,,,       //Дефайны регистров
,,,       .def           PGA                             =               R20                                             //Номер страницы
,,,       
,,,       .def           EPL                             =               R24                                             //Старший и младший байты счётчика байтов EEPROM
,,,       .def           EPH                             =               R25
,,,       
,,,       //Устройство-специфические дефайны
,,,       .equ           VER                             =               0x01                                    //Версия загрузчика
,,,       
,,,       .equ           MFID2                   =               0x0F                                    //Старший байт идентификатора разработчика
,,,       .equ           MFID1                   =               0x05                                    //Средний
,,,       .equ           MFID0                   =               0x5A                                    //Младший
,,,       
,,,       .equ           DEVID2                  =               0x00                                    //Три байта идентификатора устройства
,,,       .equ           DEVID1                  =               0x00
,,,       .equ           DEVID0                  =               0x01
,,,       
,,,       .equ           SN3                             =               0x00                                    //Четыре байта серийного номера устройства
,,,       .equ           SN2                             =               0x00
,,,       .equ           SN1                             =               0x00
,,,       .equ           SN0                             =               0x01
,,,       
,,,       
,,,       
,,,       //МК-специфические дефайны (ATmega16A)
,,,       .equ           NPT                             =               0x80                                    //Общее число страниц FLASH
,,,       
,,,       .equ           NPW                             =               0x78                                    //Число страниц, доступных на запись
,,,       
,,,       .equ           PS                              =               0x80                                    //Размер страницы FLASH (в байтах)
,,,       
,,,       .equ           PSS                             =               0x07                                    //Сколько раз надо сдвинуть влево номер страницы,
,,,       //чтобы перейти к адресу
,,,       
,,,       .equ           PSW                             =               0x40                                    //Размер страницы в словах
,,,       
,,,       
,,,       //Сегмент данных
,,,       .DSEG
,,,       
,,,       
,,,       //Сегмент кода
,,,       .CSEG
,,,       .org           0x0000                                                                                  //Точка входа в основную программу
,,,       RESET:
000000,940C,jmp                    RESET,jmp                    RESET
,,,       
,,,       
,,,       //Точка входа в загрузчик
,,,       .org           START_ADDR
,,,       
,,,       //Настраиваем стек
003C00,E004,ldi                    R16,                    high(ramend),ldi                    R16,                    high(ramend)
003C02,BF0E,out                    SPH,                    R16,out                    SPH,                    R16
003C04,E50F,ldi                    R16,                    low(ramend),ldi                    R16,                    low(ramend)
003C06,BF0D,out                    SPL,                    R16,out                    SPL,                    R16
,,,       
,,,       
,,,       //Проверяем условие входа
003C00,98B8,cbi                    LISTEN_DDR,             LISTEN_BIT                                              //Слушаемая нога - на вво,cbi                    LISTEN_DDR,             LISTEN_BIT                                              //Слушаемая нога - на ввод
003C00,9AC0,sbi                    LISTEN_PORT,    LISTEN_BIT                                              //Включаем подтягивающий резистор,sbi                    LISTEN_PORT,    LISTEN_BIT                                              //Включаем подтягивающий резистор
003C0C,99B0,sbic           LISTEN_PIN,             LISTEN_BIT,sbic           LISTEN_PIN,             LISTEN_BIT
003C00,940C,jmp                    RESET                                                                                   //На ноге высокий,jmp                    RESET                                                                                   //На ноге высокий уровень, уходим на основную программу
,,,       
,,,       
,,,       //Вход в загрузчик
,,,       
,,,       //Зажигаем светодиод
003C12,9AB9,sbi                    LED_DDR,                LED_BIT,sbi                    LED_DDR,                LED_BIT
003C14,9AC1,sbi                    LED_PORT,               LED_BIT,sbi                    LED_PORT,               LED_BIT
,,,       
,,,       //Настраиваем UART
003C16,E100,ldi                    R16,                    low(BAUDDIVIDER),ldi                    R16,                    low(BAUDDIVIDER)
003C18,B909,out                    UBRRL,                  R16,out                    UBRRL,                  R16
003C1A,E000,ldi                    R16,                    high(BAUDDIVIDER),ldi                    R16,                    high(BAUDDIVIDER)
003C1C,BD00,out                    UBRRH,                  R16,out                    UBRRH,                  R16
003C1E,2700,clr                    R16,clr                    R16
003C20,B90B,out                    UCSRA,                  R16,out                    UCSRA,                  R16
003C22,E108,ldi            R16,                    (1<<RXEN)|(1<<TXEN) //Включаем приём и передачу,ldi            R16,                    (1<<RXEN)|(1<<TXEN) //Включаем приём и передачу
003C24,B90A,out                    UCSRB,                  R16,out                    UCSRB,                  R16
003C00,E806,ldi            R16,                    (1<<URSEL)|(1<<UCSZ0)|(1<<UCSZ1) //Один стоповый бит, 8 бит данных, без проверки чётности,ldi            R16,                    (1<<URSEL)|(1<<UCSZ0)|(1<<UCSZ1) //Один стоповый бит, 8 бит данных, без проверки чётности
003C28,BD00,out                    UCSRC,                  R16,out                    UCSRC,                  R16
,,,       
,,,       //Ожидаем поступления команд
,,,       COMMAND_WAIT:
003C2A,940E,call           UART_READ_BYTE                                                                  //Принимаем байт,call           UART_READ_BYTE                                                                  //Принимаем байт
003C2E,3409,cpi                    R16,                    'I'                                                             //Идентификация,cpi                    R16,                    'I'                                                             //Идентификация
003C30,F061,breq           IDENTIFY,breq           IDENTIFY
,,,       
003C00,3507,cpi                    R16,                    'W'                                                             //Запись страницы,cpi                    R16,                    'W'                                                             //Запись страницы FLASH
003C34,F061,breq           WRITE_FLASH,breq           WRITE_FLASH
,,,       
003C00,3502,cpi                    R16,                    'R'                                                             //Чтение страницы,cpi                    R16,                    'R'                                                             //Чтение страницы FLASH
003C38,F061,breq           READ_FLASH,breq           READ_FLASH
,,,       
003C00,3707,cpi                    R16,                    'w'                                                             //Запись страницы,cpi                    R16,                    'w'                                                             //Запись страницы EEPROM
003C3C,F061,breq           WRITE_EEPROM,breq           WRITE_EEPROM
,,,       
003C00,3702,cpi                    R16,                    'r'                                                             //Чтение страницы,cpi                    R16,                    'r'                                                             //Чтение страницы EEPROM
003C40,F061,breq           READ_EEPROM,breq           READ_EEPROM
,,,       
003C00,3501,cpi                    R16,                    'Q'                                                             //Завершение прош,cpi                    R16,                    'Q'                                                             //Завершение прошивки
003C44,F061,breq           QUIT,breq           QUIT
,,,       
,,,       COMMAND_PROCESSED:                                                                                     //Обработка программы завершена
003C46,940C,jmp                    COMMAND_WAIT,jmp                    COMMAND_WAIT
,,,       
,,,       
,,,       //Обработчики команд
,,,       
,,,       //Идентификация
,,,       IDENTIFY:
003C4A,940C,jmp                    IDENTIFY_P,jmp                    IDENTIFY_P
,,,       
,,,       
,,,       //Запись страницы флеш
,,,       WRITE_FLASH:
003C4E,940C,jmp                    WRITE_FLASH_P,jmp                    WRITE_FLASH_P
,,,       
,,,       
,,,       //Чтение страницы флеш
,,,       READ_FLASH:
003C52,940C,jmp                    READ_FLASH_P,jmp                    READ_FLASH_P
,,,       
,,,       
,,,       //Запись EEPROM
,,,       WRITE_EEPROM:
003C56,940C,jmp                    WRITE_EEPROM_P,jmp                    WRITE_EEPROM_P
,,,       
,,,       //Чтение EEPROM
,,,       READ_EEPROM:
003C5A,940C,jmp                    READ_EEPROM_P,jmp                    READ_EEPROM_P
,,,       
,,,       //Завершение прошивки
,,,       QUIT:
003C5E,E402,ldi                    R16,                    'B'                                                             //Отвечаем 'B',ldi                    R16,                    'B'                                                             //Отвечаем 'B'
003C60,940E,call           UART_SEND_BYTE,call           UART_SEND_BYTE
,,,       
,,,       //Гасим светодиод и возвращаем порты в исходное состояние
003C64,98C1,cbi                    LED_PORT,               LED_BIT,cbi                    LED_PORT,               LED_BIT
003C66,98B9,cbi                    LED_DDR,                LED_BIT,cbi                    LED_DDR,                LED_BIT
003C00,98C0,cbi                    LISTEN_PORT,    LISTEN_BIT                                                      //Включаем подтягивающий ,cbi                    LISTEN_PORT,    LISTEN_BIT                                                      //Включаем подтягивающий резистор
,,,       
,,,       
003C00,940C,jmp                    RESET                                                                                           //Уходим ,jmp                    RESET                                                                                           //Уходим в основную программу           
,,,       
,,,       
,,,       //Процедура идентификации
,,,       IDENTIFY_P:
,,,       //Выкидываем сигнатуру загрузчика
003C6E,E406,ldi                    R16,                    'F',ldi                    R16,                    'F'
003C70,940E,call           UART_SEND_BYTE,call           UART_SEND_BYTE
003C74,E402,ldi                    R16,                    'B',ldi                    R16,                    'B'
003C76,940E,call           UART_SEND_BYTE,call           UART_SEND_BYTE
003C7A,E40C,ldi                    R16,                    'L',ldi                    R16,                    'L'
003C7C,940E,call           UART_SEND_BYTE,call           UART_SEND_BYTE
,,,       
,,,       //Версия загрузчика
003C80,E001,ldi                    R16,                    VER,ldi                    R16,                    VER
003C82,940E,call           UART_SEND_BYTE,call           UART_SEND_BYTE
,,,       
,,,       //Идентификатор разработчика
003C86,E00F,ldi                    R16,                    MFID2,ldi                    R16,                    MFID2
003C88,940E,call           UART_SEND_BYTE,call           UART_SEND_BYTE
003C8C,E005,ldi                    R16,                    MFID1,ldi                    R16,                    MFID1
003C8E,940E,call           UART_SEND_BYTE,call           UART_SEND_BYTE
003C92,E50A,ldi                    R16,                    MFID0,ldi                    R16,                    MFID0
003C94,940E,call           UART_SEND_BYTE,call           UART_SEND_BYTE
,,,       
,,,       //Идентификатор устройства
003C98,E000,ldi                    R16,                    DEVID2,ldi                    R16,                    DEVID2
003C9A,940E,call           UART_SEND_BYTE,call           UART_SEND_BYTE
003C9E,E000,ldi                    R16,                    DEVID1,ldi                    R16,                    DEVID1
003CA0,940E,call           UART_SEND_BYTE,call           UART_SEND_BYTE
003CA4,E001,ldi                    R16,                    DEVID0,ldi                    R16,                    DEVID0
003CA6,940E,call           UART_SEND_BYTE,call           UART_SEND_BYTE
,,,       
,,,       //Серийный номер
003CAA,E000,ldi                    R16,                    SN3,ldi                    R16,                    SN3
003CAC,940E,call           UART_SEND_BYTE,call           UART_SEND_BYTE
003CB0,E000,ldi                    R16,                    SN2,ldi                    R16,                    SN2
003CB2,940E,call           UART_SEND_BYTE,call           UART_SEND_BYTE
003CB6,E000,ldi                    R16,                    SN1,ldi                    R16,                    SN1
003CB8,940E,call           UART_SEND_BYTE,call           UART_SEND_BYTE
003CBC,E001,ldi                    R16,                    SN0,ldi                    R16,                    SN0
003CBE,940E,call           UART_SEND_BYTE,call           UART_SEND_BYTE
,,,       
003CC2,940C,jmp                    COMMAND_PROCESSED,jmp                    COMMAND_PROCESSED
,,,       
,,,       
,,,       //Чтение страницы FLASH
,,,       READ_FLASH_P:
,,,       //Читаем адрес страницы
003CC6,940E,call           UART_READ_BYTE,call           UART_READ_BYTE
003CCA,2F40,mov                    PGA,                    R16,mov                    PGA,                    R16
,,,       
,,,       //Проверяем адрес страницы
003CCC,E860,ldi                    R22,                    NPT,ldi                    R22,                    NPT
003CCE,940E,call           CHECK_PG_ADDR,call           CHECK_PG_ADDR
,,,       
003CD2,940E,call           UART_SEND_BYTE //Посылаем результат проверки адреса,call           UART_SEND_BYTE //Посылаем результат проверки адреса
,,,       
003CD6,3001,cpi                    R16,                    ERR_FAIL,cpi                    R16,                    ERR_FAIL
003CD8,F091,breq           READ_FLASH_P_EXIT //Адрес некорректен, выходим из команды,breq           READ_FLASH_P_EXIT //Адрес некорректен, выходим из команды
,,,       
,,,       
,,,       //Получаем в ZH:ZL адрес ячейки
003CDA,2700,clr                    R16,clr                    R16
003CDC,2711,clr                    R17,clr                    R17
003CDE,27FF,clr                    ZH,clr                    ZH
003CE0,2FE4,mov                    ZL,                             PGA,mov                    ZL,                             PGA
,,,       
,,,       READ_FLASH_P_NEXT_SHIFT:
,,,       //Сдвигаем адрес влево на 1
003CE2,9488,clc //Сбрасываем флаг переноса,clc //Сбрасываем флаг переноса
003CE4,0FFF,lsl                    ZH //Сдвигаем старший байт,lsl                    ZH //Сдвигаем старший байт
003CE6,0FEE,lsl                    ZL //Сдвигаем младший байт,lsl                    ZL //Сдвигаем младший байт
003CE8,1FF0,adc                    ZH,                             R16 //Прибавляем перенос к старшему,adc                    ZH,                             R16 //Прибавляем перенос к старшему
,,,       
003CEA,9513,inc                    R17,inc                    R17
003CEC,3017,cpi                    R17,                    PSS,cpi                    R17,                    PSS
003CEE,F3C8,brlo           READ_FLASH_P_NEXT_SHIFT,brlo           READ_FLASH_P_NEXT_SHIFT
,,,       
,,,       //Читаем данные страницы и отправляем их по UART
003CF0,2711,clr                    R17,clr                    R17
,,,       
,,,       //Чтение следующего байта флеш
,,,       READ_FLASH_P_NEXT_BYTE:
003CF2,9105,lpm                    R16,                    Z+,lpm                    R16,                    Z+
003CF4,940E,call           UART_SEND_BYTE,call           UART_SEND_BYTE
,,,       
003CF8,9513,inc                    R17,inc                    R17
003CFA,3810,cpi                    R17,                    PS,cpi                    R17,                    PS
003CFC,F3D0,brlo           READ_FLASH_P_NEXT_BYTE,brlo           READ_FLASH_P_NEXT_BYTE
,,,       
,,,       READ_FLASH_P_EXIT: //Выход из чтения страницы
003CFE,940C,jmp                    COMMAND_PROCESSED,jmp                    COMMAND_PROCESSED
,,,       
,,,       
,,,       //Запись страницы флеш
,,,       WRITE_FLASH_P:
,,,       //Читаем адрес страницы
003D02,940E,call           UART_READ_BYTE,call           UART_READ_BYTE
003D06,2F40,mov                    PGA,                    R16,mov                    PGA,                    R16
,,,       
,,,       //Проверяем адрес страницы
003D08,E768,ldi                    R22,                    NPW //В загрузчик писать нельзя,ldi                    R22,                    NPW //В загрузчик писать нельзя
003D0A,940E,call           CHECK_PG_ADDR,call           CHECK_PG_ADDR
,,,       
,,,       //Передаём результат проверки адреса
003D0E,940E,call           UART_SEND_BYTE,call           UART_SEND_BYTE
,,,       
003D12,3001,cpi                    R16,                    ERR_FAIL,cpi                    R16,                    ERR_FAIL
003D14,F0E1,breq           WRITE_FLASH_P_EXIT //Адрес некорректен, выходим из команды,breq           WRITE_FLASH_P_EXIT //Адрес некорректен, выходим из команды
,,,       
,,,       //Кладём адрес страницы в Z
003D16,940E,call           SET_PG_ADDR,call           SET_PG_ADDR
,,,       
,,,       //Принимаем байы попарно и кладём их в R1:R0, счётчик крутится в словах
003D1A,2711,clr                    R17,clr                    R17
,,,       
,,,       WRITE_FLASH_P_READ_WORD: //Считываем очередное слово
003D1C,940E,call           UART_READ_BYTE //Младший байт,call           UART_READ_BYTE //Младший байт
003D20,2E00,mov                    R0,                             R16,mov                    R0,                             R16
003D22,940E,call           UART_READ_BYTE //Старший байт,call           UART_READ_BYTE //Старший байт
003D26,2E10,mov                    R1,                             R16,mov                    R1,                             R16
,,,       
,,,       //Кладём слово в буфер
003D28,E001,ldi                    R16,                    (1<<SPMEN),ldi                    R16,                    (1<<SPMEN)
003D2A,940E,call           MAKE_SPM,call           MAKE_SPM
,,,       
,,,       //Инкрементим номер слова в Z
003D2E,9632,adiw           ZH,adiw           ZH:ZL,                  0x02 //Прибавляем 2, чтобы младший бит всегда оставался равен 0
,,,       
003D30,9513,inc                    R17,inc                    R17
003D32,3410,cpi                    R17,                    PSW,cpi                    R17,                    PSW
003D34,F398,brlo           WRITE_FLASH_P_READ_WORD,brlo           WRITE_FLASH_P_READ_WORD
,,,       
003D36,940E,call           SET_PG_ADDR //Перезагружаем адрес,call           SET_PG_ADDR //Перезагружаем адрес
,,,       
,,,       //Стираем страницу
003D3A,E003,ldi                    R16,                    (1<<PGERS)|(1<<SPMEN),ldi                    R16,                    (1<<PGERS)|(1<<SPMEN)
003D3C,940E,call           MAKE_SPM,call           MAKE_SPM
,,,       
,,,       //Пишем старницу
003D40,E005,ldi                    R16,                    (1<<PGWRT)|(1<<SPMEN),ldi                    R16,                    (1<<PGWRT)|(1<<SPMEN)
003D42,940E,call           MAKE_SPM,call           MAKE_SPM
,,,       
,,,       //Восстанавливаем доступ к RWW
003D46,E101,ldi                    R16,                    (1<<RWWSRE)|(1<<SPMEN),ldi                    R16,                    (1<<RWWSRE)|(1<<SPMEN)
003D48,940E,call           MAKE_SPM,call           MAKE_SPM
,,,       
,,,       //Всё успешно
003D4C,E000,ldi                    R16,                    ERR_OK,ldi                    R16,                    ERR_OK
,,,       
,,,       WRITE_FLASH_P_EXIT: //Выход из стирания страницы
003D4E,940E,call           UART_SEND_BYTE //Посылаем результат,call           UART_SEND_BYTE //Посылаем результат
003D52,940C,jmp                    COMMAND_PROCESSED,jmp                    COMMAND_PROCESSED
,,,       
,,,       
,,,       //Чтение EEPROM
,,,       READ_EEPROM_P:
,,,       //Сбрасываем адрес
003D56,27AA,clr                    XL,clr                    XL
003D58,27BB,clr                    XH,clr                    XH
,,,       
,,,       //Загружаем в счётчик цикла число байт EEPROM
003D5A,E091,ldi                    EPH,                    high(EEPROMEND),ldi                    EPH,                    high(EEPROMEND)
003D5C,EF8F,ldi                    EPL,                    low(EEPROMEND),ldi                    EPL,                    low(EEPROMEND)
,,,       
,,,       
,,,       READ_EEPROM_P_NEXT_BYTE: //Читаем очередной байт
,,,       
,,,       //Не идёт ли запись EEPROM можно не проверять, так как к вызову этой команды она гарантировано завершена
003D5E,BBBF,out                    EEARH,                  XH,out                    EEARH,                  XH
003D60,BBAE,out                    EEARL,                  XL,out                    EEARL,                  XL
003D62,9AE0,sbi                    EECR,                   EERE //Инициируем чтение,sbi                    EECR,                   EERE //Инициируем чтение
003D64,B30D,in                     R16,                    EEDR,in                     R16,                    EEDR
003D66,940E,call           UART_SEND_BYTE //Посылаем полученный байт,call           UART_SEND_BYTE //Посылаем полученный байт
,,,       
,,,       //Инкрементим адрес и декрементим счётчик
003D6A,9611,adiw           XH,adiw           XH:XL,                  0x01
003D6C,9701,sbiw           EPH,sbiw           EPH:EPL,                0x01
003D6E,F7B8,brsh           READ_EEPROM_P_NEXT_BYTE,brsh           READ_EEPROM_P_NEXT_BYTE
,,,       
003D70,940C,jmp                    COMMAND_PROCESSED,jmp                    COMMAND_PROCESSED
,,,       
,,,       
,,,       //Запись EEPROM
,,,       WRITE_EEPROM_P:
,,,       //Сбрасываем адрес
003D74,27AA,clr                    XL,clr                    XL
003D76,27BB,clr                    XH,clr                    XH
,,,       
,,,       //Загружаем в счётчик цикла число байт EEPROM
003D78,E091,ldi                    EPH,                    high(EEPROMEND),ldi                    EPH,                    high(EEPROMEND)
003D7A,EF8F,ldi                    EPL,                    low(EEPROMEND),ldi                    EPL,                    low(EEPROMEND)
,,,       
,,,       
,,,       WRITE_EEPROM_P_NEXT_BYTE: //Пишем очередной байт
,,,       //Принимаем байт
003D7C,940E,call           UART_READ_BYTE,call           UART_READ_BYTE
,,,       
,,,       //Ждём завершения предыдущей записи
,,,       WRITE_EEPROM_P_WAIT:
003D80,99E1,sbic           EECR,                   EEWE,sbic           EECR,                   EEWE
003D82,CFFE,rjmp           WRITE_EEPROM_P_WAIT,rjmp           WRITE_EEPROM_P_WAIT
,,,       
,,,       //Проводим запись
003D84,BBBF,out                    EEARH,                  XH,out                    EEARH,                  XH
003D86,BBAE,out                    EEARL,                  XL,out                    EEARL,                  XL
003D88,BB0D,out                    EEDR,                   R16,out                    EEDR,                   R16
003D8A,9AE2,sbi                    EECR,                   EEMWE,sbi                    EECR,                   EEMWE
003D8C,9AE1,sbi                    EECR,                   EEWE,sbi                    EECR,                   EEWE
,,,       
,,,       //Инкрементим адрес и декрементим счётчик
003D8E,9611,adiw           XH,adiw           XH:XL,                  0x01
003D90,9701,sbiw           EPH,sbiw           EPH:EPL,                0x01
003D92,F428,brsh           WRITE_EEPROM_P_WANT_NEXT,brsh           WRITE_EEPROM_P_WANT_NEXT
,,,       
,,,       //Все байты записаны
003D94,E606,ldi                    R16,                    'f',ldi                    R16,                    'f'
003D96,940E,call           UART_SEND_BYTE,call           UART_SEND_BYTE
003D9A,940C,jmp                    COMMAND_PROCESSED,jmp                    COMMAND_PROCESSED
,,,       
,,,       //Хотим ещё байт
,,,       WRITE_EEPROM_P_WANT_NEXT:
003D9E,E60E,ldi                    R16,                    'n',ldi                    R16,                    'n'
003DA0,940E,call           UART_SEND_BYTE,call           UART_SEND_BYTE
003DA4,CFEB,rjmp           WRITE_EEPROM_P_NEXT_BYTE,rjmp           WRITE_EEPROM_P_NEXT_BYTE
,,,       
,,,       
,,,       //Процедуры
,,,       
,,,       //Процедура отправляет байт по UART. Байт должен лежать в R16
,,,       UART_SEND_BYTE:
003DA6,931F,,       push            R17
003DA8,B71F,,       in                      R17,                    SREG
003DAA,931F,,       push            R17
,,,       
,,,              UART_SEND_BYTE_WAIT_READY:
003DAC,9B5D,,       sbis            UCSRA,                  UDRE
003DAE,CFFE,,       rjmp            UART_SEND_BYTE_WAIT_READY
,,,       
003DB0,B90C,,       out                     UDR,                    R16
,,,       
003DB2,911F,,       pop                     R17
003DB4,BF1F,,       out                     SREG,                   R17
003DB6,911F,,       pop                     R17
003DB8,9508,ret,ret
,,,       
,,,       //Процедура принимает байт по UART. Висит внутри себя пока не будет принят байт. Полученный байт
,,,       //кладётся в R16
,,,       UART_READ_BYTE:
003DBA,931F,,       push            R17
003DBC,B71F,,       in                      R17,                    SREG
003DBE,931F,,       push            R17
,,,       
,,,              UART_READ_BYTE_WAIT:
003DC0,9B5F,,       sbis            UCSRA,                  RXC
003DC2,CFFE,,       rjmp            UART_READ_BYTE_WAIT
003DC4,B10C,,       in                      R16,                    UDR
,,,       
,,,       ////Затычка бага с 0x00 в терминале протеуса
,,,       //ldi          R17,    '/'
,,,       //cpse R16,    R17
,,,       //rjmp UART_READ_BYTE_EXIT
,,,       //clr          R16
,,,       
,,,       UART_READ_BYTE_EXIT:
003DC6,911F,,       pop                     R17
003DC8,BF1F,,       out                     SREG,                   R17
003DCA,911F,,       pop                     R17
003DCC,9508,ret,ret
,,,       
,,,       
,,,       //Процедура проверяет адрес страницы на корректность. Адрес страницы должен лежать в PGA,
,,,       //число страниц - в R22. Адрес страницы должен быть меньше числа страниц. Если это так - возвращает
,,,       //в R16 ERR_OK, иначе ERR_FAIL
,,,       CHECK_PG_ADDR:
003DCE,931F,,       push            R17
003DD0,B71F,,       in                      R17,                    SREG
003DD2,931F,,       push            R17
,,,       
,,,              //Сравниваем старшие байты адреса
003DD4,1746,,       cp                      PGA,                    R22
003DD6,F010,,       brlo            CHECK_PG_ADDR_OK //PGAH < R22, адрес корректен
,,,       
,,,              //Адрес некорректен
003DD8,E001,,       ldi                     R16,                    ERR_FAIL
003DDA,C002,,       rjmp            CHECK_PG_ADDR_EXIT
,,,       
,,,       CHECK_PG_ADDR_OK: //Адрес корректен
003DDC,E000,,       ldi                     R16,                    ERR_OK
003DDE,C000,,       rjmp            CHECK_PG_ADDR_EXIT
,,,       
,,,       CHECK_PG_ADDR_EXIT: //Выход из процедуры
003DE0,911F,,       pop                     R17
003DE2,BF1F,,       out                     SREG,                   R17
003DE4,911F,,       pop                     R17
003DE6,9508,ret,ret
,,,       
,,,       //Процедура выполняет команду SPM. Значение, записываемое в SPMCR, должно лежать в R16.
,,,       //Будучи вызванной ждёт завершения предыдущей команды SPM, до завершения выполнения оной зацикливается.
,,,       MAKE_SPM:
003DE8,931F,,       push            R17
003DEA,B71F,,       in                      R17,                    SREG
003DEC,931F,,       push            R17
,,,       
,,,       MAKE_SPM_WAIT1: //Ждём завершения предыдущей команды SPM
003DEE,B717,,       in                      R17,                    SPMCR
003DF0,FD10,,       sbrc            R17,                    SPMEN
003DF2,CFFD,,       rjmp            MAKE_SPM_WAIT1
,,,       
,,,              //Собственно выполняем команду
003DF4,BF07,,       out                     SPMCR,                  R16
003DF6,95E8,,       spm
,,,       
003DF8,911F,,       pop                     R17
003DFA,BF1F,,       out                     SREG,                   R17
003DFC,911F,,       pop                     R17
003DFE,9508,ret,ret
,,,       
,,,       //Процедура преобразует номер страницы (лежащий в PGA) в адрес страницы. Адрес кладётся в
,,,       //Z13:Z7, все остальные биты регистра Z обнуляются
,,,       SET_PG_ADDR:
003E00,930F,,       push            R16
003E02,B70F,,       in                      R16,                    SREG
003E04,930F,,       push            R16
,,,       
003E06,2FE4,,       mov                     ZL,                             PGA
003E08,70E1,,       andi            ZL,                             0b00000001 //Выделяем младший бит адреса
003E0A,FBE0,,       bst                     ZL,                             0x00 //Перекладываем его в старший бит
003E0C,27EE,,       clr                     ZL
003E0E,F9E7,,       bld                     ZL,                             0x07
,,,       
003E10,2FF4,,       mov                     ZH,                             PGA
003E12,77FE,,       andi            ZH,                             0b01111110 //Выделяем старшие биты адреса
003E14,95F6,,       lsr                     ZH
,,,       
003E16,910F,,       pop                     R16
003E18,BF0F,,       out                     SREG,                   R16
003E1A,910F,,       pop                     R16
003E1C,9508,ret,ret
,,,
,,,
